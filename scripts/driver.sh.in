#!/bin/bash

# -----------------------------------------------------------------------------
# !!!!! AUTO-GENERATED BY CMAKE; DO NOT EDIT !!!!! 
# -----------------------------------------------------------------------------
# Instead refer project/scripts/driver.sh.in

export SOFICS_ROOT="@CMAKE_INSTALL_PREFIX@"
export SOFICS_BIN="$SOFICS_ROOT/bin"
export SOFICS_VERSION="@PROJECT_VERSION@"

# TODO: Maybe add SOFICS_BIN to PATH

export DEFAULT_AEROS_EXE="${SOFICS_BIN}/aeros"
export DEFAULT_M2C_EXE="${SOFICS_BIN}/m2c"
export GMSH2AEROS_EXE="${SOFICS_BIN}/gmsh2aeros"
export AEROS2DAKOTA_EXE="${SOFICS_BIN}/aeros2dakota"

echo "SOFICS @PROJECT_VERSION@ loaded"
echo "Root: ${SOFICS_ROOT}"

#------------------------------------------------------------------------------
# Get all global variables in the CURRENT shell
#------------------------------------------------------------------------------
source "${SOFICS_BIN}/global_defs.sh"

#------------------------------------------------------------------------------
# Parse command-line in the SAME shell
#------------------------------------------------------------------------------
if ! source "${SOFICS_BIN}/command_line_parser.sh" "$@"
then
  exit 1
fi

#------------------------------------------------------------------------------
# Get current evaluation id
#------------------------------------------------------------------------------
set -o pipefail
DAK_EVAL_NUM=$(
  grep "eval_id" "$DAK_PARAMS" | awk '{print $1}'
)
if [ "$?" -ne 0 ]; then
  printf "*** Error: Could not get the evaluation ID from the "
  printf "parameters file. Required for SOFICS. Aborting ...\n"
  exit 1
fi
set +o pipefail

#------------------------------------------------------------------------------
# Internal variables (local to current shell)
#------------------------------------------------------------------------------
# Internal variables for ADOPT.
SOLVER_TYPE="TRUE"

# Internal scripts
ANALYSIS_SETUP_FILE="${SOFICS_BIN}/analysis_setup.sh"
META_GENERATOR_FILE="${SOFICS_BIN}/meta_generator.sh"

# Internal drivers
TRUE_EVALUATION_DRIVER="${SOFICS_BIN}/fsi_driver.sh"
APPROX_EVALUATION_DRIVER="${SOFICS_BIN}/approx_fsi_driver.sh"
ERROR_EVALUATION_DRIVER="${SOFICS_BIN}/error_driver.sh"

#------------------------------------------------------------------------------
# Get user config in the CURRENT shell
#------------------------------------------------------------------------------
if [ -n "$USER_CONFIG" ]; then
  source "$USER_CONFIG"
fi

# additional checks and warnings. Analysis specific checks are 
# undertaken in analysis setup script.
if [ -z "$EVALUATION_CONCURRENCY" ]; then
  printf "*** Warning: Evaluation concurrency needs to be defined in the "
  printf "configuration file as well. Should match dakota input file for "
  printf "asynchronous evaluations. Setting default value 1.\n"
  EVALUATION_CONCURRENCY=1
fi

if [ -z "$LOCAL_SCHEDULING"]; then
  LOCAL_SCHEDULING="STATIC"
fi

#------------------------------------------------------------------------------
# Process parameters and call the structural pre-processor
#------------------------------------------------------------------------------
source "$ANALYSIS_SETUP_FILE"

#------------------------------------------------------------------------------
# Execute analysis in a sub-shell.
#------------------------------------------------------------------------------

start_time=$(date +%s)

case "$SOLVER_TYPE" in
  
  TRUE)
    bash "$TRUE_EVALUATION_DRIVER" ;;
  APPROX)
    bash "$APPROX_EVALUATION_DRIVER" ;;
  ERROR)
    bash "$ERROR_EVALUATION_DRIVER" ;;

esac

elapsed_time=$(( $(date +%s) - start_time ))

case "$SOLVER_TYPE" in

  TRUE)
    printf "\033[32mTotal time for Evaluation %s = %s s.\033[0m\n" \
      "$DAK_EVAL_NUM" "$elapsed_time" ;;
  APPROX)
    printf "\033[32mTotal time for (Approx) Evaluation %s = %s s.\033[0m\n" \
      "$DAK_EVAL_NUM" "$elapsed_time" ;;

esac

#------------------------------------------------------------------------------
# Post-processing
#------------------------------------------------------------------------------

# check which signal was recieved and handle errors here
# Alternatively, we could also query $? as it returns the
# exit status of mpiexec.
if grep -q "NORMAL TERMINATION" "$WORKING_DIR/log.out"
then
  # succesfull evaluation
  if [[ "$SOLVER_TYPE" != "ERROR" ]]; then
    
    # execute post-processor in a sub-shell
    if ! bash "$POSTPROCESS_FILE"; then
      printf "*** Error: Failed at post-processing stage for design "
      printf "%s.\n" "${DAK_EVAL_NUM}"
      # Here we let dakota capture the failure and proceed 
      # based on user specification.
      
      printf "FAIL\n" > "$WORKING_DIR/$DAK_RESULTS"
      exit 0
    fi

  else

    NRMSE=$(
      grep "Mean Squared Error" "$WORKING_DIR/log.out" |
      sed 's/.*: //; s/\.$//'
    )

    printf "    %s  MSE\n" "$NRMSE" >> "$WORKING_DIR/$DAK_RESULTS"
  fi
else
  # unsuccessfull evaluation
  printf "FAIL\n" > "$WORKING_DIR/$DAK_RESULTS"
fi

#------------------------------------------------------------------------------
# Exit analysis driver.
#------------------------------------------------------------------------------
exit 0
