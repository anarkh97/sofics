#include "LeastSquareSolver.h"
#include <algorithm>

extern "C" {
  // LAPACK: QR factorization with column pivoting (A*P = Q*R)
  void _FORTRAN(dgeqp3)(const int* m, const int* n, double* a, const int* lda, int* jptv,
                        double* tau, double* work, const int* lwork, int* info);

  // LAPACK: Multiplication by orthogonal Q generated by DGEQP3
  void _FORTRAN(dormqr)(const char* side, const char* trans, const int* m, const int* n, const int* k,
                        const double* a, const int* lda, const double * tau, double * c, const int* ldc,
                        double* work, const int* lwork, int* info);

  // BLAS: Backward/Forward substitution
  void _FORTRAN(dtrsv)(const char* uplo, const char* trans, const char* diag, const int* n,
                       const double* a, const int* lda, double* x, const int* incx);
}

namespace Pita {

LeastSquareSolver::LeastSquareSolver(double tol) :
  RankDeficientSolver(tol),
  transposedMatrix_(),
  tau_(), 
  workspace_()
{}

void
LeastSquareSolver::transposedMatrixIs(const FullSquareMatrix & transposedMatrix) {
  transposedMatrix_.copy(transposedMatrix);
  setMatrixSize(transposedMatrix_.dim());

  // Initialize arrays for factorization
  setVectorSize(matrixSize());
  setOrdering(PERMUTED);
  getFactorPermutation().sizeIs(vectorSize());
  
  // All columns are free
  std::fill_n(getFactorPermutation().array(), getFactorPermutation().size(), 0);

  tau_.sizeIs(matrixSize());

  const int workspaceSize = 3 * matrixSize() + 1; // TODO optimize ?
  workspace_.sizeIs(workspaceSize); 

  int info;

  // Perform factorization
  _FORTRAN(dgeqp3)(&getMatrixSize(), &getMatrixSize(), transposedMatrix_.data(), &getMatrixSize(), getFactorPermutation().array(),
      tau_.array(), workspace_.array(), &workspaceSize, &info);

  // Determine numerical rank
  updateFactorRank();
}

void
LeastSquareSolver::toleranceIs(double tol) {
  if (tolerance() != tol) {
    setTolerance(tol);
    if (matrixSize() > 0) {
      updateFactorRank();
    }
  }
}

const Vector &
LeastSquareSolver::solution(Vector & rhs) const {
  if (this->matrixSize() != rhs.size()) {
    throw Fwk::RangeException("in LeastSquareSolver::solution - Size mismatch");
  }

  // 1) rhs(1:rank) <- Q_1^T rhs
  const char side = 'L';   // Multiply on the left
  const char qTrans = 'T'; // Transpose the matrix
  const int cols = 1;      // Single rhs vector
  
  const int workspaceSize = workspace_.size(); // TODO optimize
  workspace_.sizeIs(workspaceSize);

  int info;

  _FORTRAN(dormqr)(&side, &qTrans, &getMatrixSize(), &cols, &getFactorRank(),
                   transposedMatrix_.data(), &getMatrixSize(), tau_.array(), rhs.data(), &getMatrixSize(),
                   workspace_.array(), &workspaceSize, &info); 

  // 2) rhs(1:rank) <- R_{11}^-1 rhs(1:rank)
  const char uplo = 'U';   // Upper triangular (in Fortran indexing)
  const char sTrans = 'N'; // No transpose
  const char diag = 'N';   // Non-unit diagonal
  const int incx = 1;      // Rhs vector elements are contiguous

  _FORTRAN(dtrsv)(&uplo, &sTrans, &diag, &getFactorRank(), transposedMatrix_.data(),
                  &getMatrixSize(), rhs.data(), &incx);

  // 3) rhs(perm) <- [rhs(1:rank); zeros(matrixSize - rank, 1)]
  std::copy(rhs.data(), rhs.data() + factorRank(), workspace_.array());
  rhs.zero();
  double * rhs_ptr = rhs.data() - 1; // Fortran -> C indexing
  for (int i = 0; i < factorRank(); ++i) {
    rhs_ptr[getFactorPermutation()[i]] = workspace_[i];
  }

  return rhs;
}

void
LeastSquareSolver::orderingIs(Ordering o) {
  if (ordering() == o)
    return;
  
  throw Fwk::RangeException("Forbidden transition");
  setOrdering(o);
}

void
LeastSquareSolver::updateFactorRank() {
  double diagMax = std::abs(transposedMatrix_[0][0]);
  int fr = 0;
  while (fr < vectorSize() && std::abs(transposedMatrix_[fr][fr]) > tolerance() * diagMax) {
    ++fr;
  }
  setFactorRank(fr);
}

} /* end namespace Pita */
