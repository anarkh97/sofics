/** \page feti_alg The FETI-DP Algorithm.
\htmlonly
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "all" } }
});
</script>
    \(
        \def\KK{\bf K}
        \def\AA{\bf A}
        \def\BB{\bf B}
        \def\CC{\bf C}
        \def\DD{\bf D}
        \def\FF{\bf F}
        \def\II{\bf I}
        \def\MM{\bf M}
        \def\QQ{\bf Q}
        \def\RR{\bf R}
        \def\VV{\bf V}
        \def\aa{\bf a}
        \def\bb{\bf b}
        \def\dd{\bf d}
        \def\ff{\bf f}
        \def\pp{\bf p}
        \def\qq{\bf q}
        \def\rr{\bf r}
        \def\uu{\bf u}
        \def\mmu{\boldsymbol \mu}
        \def\llambda{\boldsymbol{\lambda}}
        \def\xxi{\boldsymbol \xi}
        \def\Kcr{\KK_{cr}}
        \def\Kcc{\KK_{cc}}
        \def\Krr{\KK_{rr}}
        \def\Krc{\KK_{rc}}
        \def\Kccstar{\KK_{cc}^\star}
        \def\ZO{\bf 0}
        \def\subs{s}
        \def\diag{diag}
    \)
\endhtmlonly
\latexonly
        \def\KK{\bf K}
        \def\AA{\bf A}
        \def\BB{\bf B}
        \def\CC{\bf C}
        \def\DD{\bf D}
        \def\FF{\bf F}
        \def\II{\bf I}
        \def\MM{\bf M}
        \def\QQ{\bf Q}
        \def\RR{\bf R}
        \def\VV{\bf V}
        \def\aa{\bf a}
        \def\bb{\bf b}
        \def\dd{\bf d}
        \def\ff{\bf f}
        \def\pp{\bf p}
        \def\qq{\bf q}
        \def\rr{\bf r}
        \def\uu{\bf u}
        \def\mmu{\boldsymbol \mu}
        \def\llambda{\boldsymbol{\lambda}}
        \def\xxi{\boldsymbol \xi}
        \def\Kcr{\KK_{cr}}
        \def\Kcc{\KK_{cc}}
        \def\Krr{\KK_{rr}}
        \def\Krc{\KK_{rc}}
        \def\Kccstar{\KK_{cc}^\star}
        \def\ZO{\bf 0}
        \def\subs{s}
        \def\diag{diag}
\endlatexonly
\section feti_intro Introduction.
FETI-DP is used to solve problems of the type:
\f[
\KK \uu = \ff
\f]
\section ml_fetidp Multi-Level FETI-DP
The multi-level FETI-DP solver is an alternative implementation  of the original FETI-DP iterative solver designed to address the bottleneck associated with the solution of a  coarse problem on very large scale computing systems. It is based on using FETI-DP itself in a recursive manner for solving all coarse problems but the last one. In the next section, the original FETI-DP method is overviewed. The modifications introduced by the multi-level version of this domain decomposition based iterative method are described in the following section.
\section feti_dp FETI-DP
The FETI-DP method is a variant of the Finite Element Tearing and Interconnecting (FETI) class of equation solvers. As the name implies,
it targets equations generated by Finite Element modeling. Its starting point is to decompose the computational domain \f$\Omega\f$ into \f$N\f$ non
overlapping subdomains \f$\Omega^s\f$. In this decomposition, some of the nodes of the original problem will appear in several subdomains.
Similarly, the Degrees of Freedom (DOFs) associated with the duplicated nodes will also be duplicated.
In FETI-DP, some nodes --preferably shared by more than two subdomains-- will be chosen as {\em corner nodes}. The DOFs associated with
these corner nodes, will {\em not} be duplicated but instead kept as global variables. These DOFs are referred to as the Primal DOFs of the FETI-DP method.
They allow the formulation of local equation systems in which the subdomain matrices are non-singular and constitute the foundation of the global coarse problem.
\subsection fetidp_eq FETI-DP Equations
\subsubsection feti_teading Tearing
Denoting by \f$\uu\f$ the DOFs of the original problem, let the system of equations to be solved be
\f[
\KK \uu = \ff
\f]
The corner DOFs are a part of \f$\uu\f$ and can be extracted by applying a restriction matrix \f$\CC\f$:
\f[
\uu_c = \CC \uu
\f]
The non-corner DOFs are called the {\em remaining} DOFs and for each subdomain, can be obtained by applying
a restriction matrix \f$\RR^s\f$:
\f[
\uu_r^s = \RR^s\uu
\f]
Similarly one can form the coarse matrix, the local stiffness matrices associated with \f$\uu_r^s\f$ 
\f[
\begin{array}{ll}
&\KK_{rr}^s= \RR^s\KK{\RR^s}^T\\
&\KK_{cc}= \CC\KK{\CC}^T
\end{array}
\f]
as well as the matrix coupling the remaining DOFs with the corner DOFs:
\f[
\KK_{rc}^s = \RR^s\KK \CC^T
\f]
For the right hand side, the subdomain load applied on the shared DOFs  is not duplicated; instead the total load obtained by combining the forces applied to the remaining DOFs of each subdomain, \f$\ff^s\f$, and to the corner DOFs, \f$\ff_c\f$, are constructed to be equivalent to their counterpart from the original problem -- that is,
\f[
\CC^T \ff_c + \sum_{s} {\RR^s}^T \ff^s = \ff
\f]
It is obvious that this equation does not uniquely define the distribution of the load on the interface DOFs. However, any distribution satisfying this equation is mathematically equivalent
though different distributions may result in different convergence histories for the iterative method described below.

\subsubsection feti_interconnect Interconnecting
Let  \f$\uu_r\f$  denote the vector of the remaining DOFs for all the subdomains, partitioned such that \f$\uu_r^T = ({\uu_r^{1} }^T . . . ~{\uu_r^\subs}^T...~{\uu_r^N}^T)\f$. We note that the
duplicated DOFs must be equal in all the subdomains where they appear. This fact can be stated in matrix form by writing all the equalities this entails using a matrix \f$\BB\f$ whose entries are all \f$0, 1\f$ or \f$-1\f$:
\f[
\BB \uu_r = \ZO
\f]
These equalities will be enforced with the use of a vector of Lagrange multipliers \f$\llambda\f$. Let the following matrices be the assemblies necessary to match the assembly 
of the \f$\uu_r\f$ vector:
\f[
\begin{array}{ll}
&\KK_{rr}= \diag (\KK_{rr}^1 . . . ~{\KK_{rr}^\subs}...~{\KK_{rr}^N})\\
&\KK_{rc}^T = \Kcr = ({\KK_{cr}^1} . . . ~{\KK_{cr}^\subs}...~{\KK_{cr}^N})
\end{array}
\f]
Using the above notation, the fundamental FETI-DP equation can be written as:
\f[\label{fetidpfull}
\begin{bmatrix}
\KK_{rr} & \KK_{rc} & \BB^T \\
\KK_{cr} & \KK_{cc} & \ZO  \\
\BB & \ZO & \ZO 
\end{bmatrix}
\begin{bmatrix}
\uu_r \\ \uu_c \\ \llambda 
\end{bmatrix} = \begin{bmatrix}
\ff_r \\ \ff_c \\ \ZO 
\end{bmatrix},
\f]
It can be shown that this equation is equivalent to the original equation to be solved. 
\subsubsection feti_augmentation Augmentation
For many types of problems, the equation just derived leads to a method that does not exhibit good numerical scalability. 
To achieve such scalability, an {\em augmentation} approach is used for the coarse problem.
It consists in adding optional equations that are simply an averaging of the interconnection equation. Let \f$\QQ\f$ be any matrix with as many columns as there are rows in \f$\BB\f$.
Then
\f[
\QQ \BB \uu_r = \QQ_r \uu_r = \ZO
\f]
By introducing associated Lagrange multipliers \f$\mmu\f$, the FETI-DP equation with augmentation is thus
\f[\label{fetidpaugmented}
\begin{bmatrix}
\KK_{rr} & \KK_{rc} & \QQ_r^T & \BB^T \\
\KK_{cr} & \KK_{cc} & \ZO &\ZO  \\
\QQ_r & \ZO & \ZO & \ZO \\
\BB & \ZO & \ZO & \ZO 
\end{bmatrix}
\begin{bmatrix}
\uu_r \\ \uu_c \\ \mmu \\ \llambda 
\end{bmatrix} = \begin{bmatrix}
\ff_r \\ \ff_c \\ \ZO \\ \ZO
\end{bmatrix},
\f]
The \f$\QQ\f$ matrix is arbitrary but some  \f$\QQ\f$ matrices lead to a better convergence rate than others. Denoting by \f$\qq_i\f$ a row in the \f$\QQ\f$ matrix,
each entry in this row multiplies the difference of primal values between two subdomains. Thus each row represents a weighted average of differences
of primal DOFs on the interface. For all the augmentations available in the FETI-DP library, each \f$\qq_i\f$ is confined to touch only two subdomains.
 The following choices are the ones available in the FETI-DP library:
    - For solid and structural mechanics type of problems, on each interface between two subdomains:
        - Sum of differences of DOFs corresponding to displacements in \f$x\f$, \f$y\f$ and \f$z\f$.
        - Weighted sum of differences of DOFs,
        with weights chosen to match rigid rotations around the center of the interface between two subdomains.
    - For acoustic computations in the frequency-domain type of problems:
        - Weighted sum of differences of DOFs, with a weight chosen as the trace of a plane wave on the interface -- that is:
          \f[
          q_{i,j} = c_1 \cos (\vec k_i \cdot \vec x_j) + c_2 \sin  (\vec k_i \cdot \vec x_j)~~~~~\forall j \in \Gamma_{s_1,s_2}
          \f]
          where \f$\Gamma_{s_1,s_2}\f$ is the set of DOFs on the interface between subdomains \f$s_1\f$ and \f$s_2\f$ on which \f$q_i\f$ lives; and each \f$\vec k_i\f$ is a vector whose norm is equal to the wave
          number of the Helmholtz equation being solved, and whose direction is given by a uniform partitioning of a circle of unit radius in 2D or a sphere of unit radius in 3D in a user-specified number of directions.

\subsubsection dp_solving Solving the FETI-DP Equation
The foundation of the solution aspect of the FETI-DP method is to apply an iterative Krylov-type algorithm to the Schur complement of the equations governing the DOFs \f$\uu_r\f$ and \f$\uu_c\f$, and \f$\mmu\f$ leaving only the Lagrange multipliers \f$\llambda\f$:
 \f[
 \begin{bmatrix}\BB & \ZO & \ZO \end{bmatrix} 
 \begin{bmatrix}
\KK_{rr} & \KK_{rc} & \QQ_r^T\\
\KK_{cr} & \KK_{cc} & \ZO \\
\QQ_r & \ZO & \ZO
\end{bmatrix}^{-1}
\begin{bmatrix}\BB^T \\ \ZO \\ \ZO \end{bmatrix}  \llambda =
\begin{bmatrix}\BB & \ZO & \ZO \end{bmatrix} 
\begin{bmatrix}
\KK_{rr} & \KK_{rc} & \QQ_r^T\\
\KK_{cr} & \KK_{cc} & \ZO \\
\QQ_r & \ZO & \ZO
\end{bmatrix}^{-1}
\begin{bmatrix}
\ff_r \\ \ff_c \\ \ZO
\end{bmatrix},
 \f]
This can be written in compact form:
\f[
 \FF \llambda = \bb
\f]
 One should note that, because of the arbitrary nature of the \f$\QQ_r\f$ matrix which could be row-deficient, the matrix to be inverted above may be singular.
 In such a case, the inverse can be replaced by a pseudo inverse. One should also note that any pseudo inverse will lead to the same solution in the original DOFs \f$\uu\f$.
For structural problems, whether static or dynamic problems, the \f$\KK\f$ matrix and all its derived versions are symmetric positive definite and therefore one can show that \f$\FF\f$ is in this case a positive semi-definite matrix. It is thus possible to apply the preconditioned conjugate gradient (PCG) method for the solution of \f$\FF \llambda = \bb\f$. For complex-valued acoustic problems in the frequency domain, FETI-DPH uses for this purpose  a preconditioned generalized minimum residual (PGMRES) algorithm.
\subsubsection{Preconditioning}
In a structural problem, the  Lagrange multipliers \f$\llambda\f$ in a structural problem are equivalent to forces binding duplicated nodes together. On the right hand side of the 
governing FETI-DP equations, the vector \f$\bb\f$ is a displacement jump. It is therefore natural that the preconditioner matrix \f$\MM^{-1}\f$ should transform a displacement jump back into a force increment. The so-called Dirichlet preconditioner described below should therefore feel natural. Let \f$\uu_r^s\f$ be partitioned into  \f$\uu_i^s\f$ and \f$\uu_b^s\f$ where the former contains all the DOFs of \f$\uu_r\f$ that do not touch any interface, and the latter contains all the DOFs on a boundary interface with other subdomains. The subdomain system matrices can be partitioned accordingly as follows:
\f[
\KK_{rr}^s = 
\begin{bmatrix}
\KK^s_{ii} & \KK^s_{ib} \\
\KK^s_{bi} & \KK^s_{bb}
\end{bmatrix}
\f]
Then the Dirichlet preconditioner is given by:
\f[
\MM^{-1} = \sum_s \BB^s (\KK^s_{bb} - \KK^s_{bi}{\KK^s_{ii}}^{-1}\KK^s_{ib}){\BB^s}^T
\f]
where \f$\BB^s\f$ is the restriction of \f$\BB\f$ to subdomain \f$\Omega^s\f$. This preconditioner has been shown to guarantee the numerical scalability of the FETI-DP method with respect to the mesh size h, the subdomain size H, and the number of elements per subdomain H/h.

\subsubsection{Parallel Implementation}
The bulk of the work is performed in computing and applying the action of the matrix
 \f[
 \begin{bmatrix}
\KK_{rr} & \KK_{rc} & \QQ_r^T\\
\KK_{cr} & \KK_{cc} & \ZO \\
\QQ_r & \ZO & \ZO
\end{bmatrix}^{-1}
\f]
on a vector. The matrix \f$\KK_{rr}\f$ is block diagonal with one block per subdomain. We can thus factor this matrix in a trivially-parallel manner. 
The matrix \f$\KK_{cc}\f$ is 
global however and so is the augmentation matrix. The inverse matrix that is needed can be processed by first forming the Schur complement with respect to the \f$\uu_r\f$ DOFs. Let
\f[
\KK_{cc} ^\star=
 \begin{bmatrix}
\KK_{cc}-\KK_{cr}\KK_{rr}^{-1}\KK_{rc} & - \KK_{cr}\KK_{rr}^{-1}\QQ_r^T \\
-\QQ_r \KK_{rr}^{-1} \KK_{rc} & -\QQ_r \KK_{rr}^{-1} \QQ_r^T
 \end{bmatrix}
\f]
This equation can also be rewritten in terms of its subdomain by subdomain contributions as follows:
\f[
\KK_{cc}^\star=
\sum_s
 \begin{bmatrix}
\KK_{cc}^\subs-\KK_{cr}^\subs {\KK_{rr}^\subs}^{-1}\KK_{rc}^\subs & - \KK_{cr}^\subs{\KK_{rr}^\subs}^{-1}{\QQ_r^\subs}^T \\
-\QQ_r^\subs {\KK_{rr}^\subs}^{-1} \KK_{rc}^\subs  & -\QQ_r^\subs{\KK_{rr}^\subs}^{-1} {\QQ_r^\subs}^T
\end{bmatrix}
\f]
Note that:
    - Each term in the anove matrix can be computed in parallel, subdomain by subdomain.
    - The sum --also called the assembly-- is a global operation. 
    - The resulting matrix is sparse, resembling that of Finite Element matrices where each subdomain plays the role of a super-element.
    - This matrix is not positive because of its lower right term.

The matrix \f$\KK_{cc}^\star\f$ is either replicated and solved on each MPI process or stored and solved using a distributed direct parallel solver such as MUMPS.
Using the notation above, to solve an equation of the form
\f[
 \begin{bmatrix}
\KK_{rr} & \KK_{rc} & \QQ_r^T\\
\KK_{cr} & \KK_{cc} & \ZO \\
\QQ_r & \ZO & \ZO
\end{bmatrix}
\begin{bmatrix}
\tilde\uu_r \\\tilde \uu_c \\ \tilde\mmu
\end{bmatrix} 
=\begin{bmatrix}
\tilde\ff_r \\ \tilde\ff_c \\ \ZO
\end{bmatrix},
\f]
the following steps are performed:
    -# Compute in parallel, subdomain per subdomain \f$\hat\ff_c^\subs\f$ and \f$\hat\ff_\mu\f$:
    \f[
    \begin{array}{ll}
    &\hat\ff_c^\subs = \Kcr^\subs{\Krr^\subs}^{-1}\tilde\ff_r^\subs \\
    &\hat\ff_\mu^\subs = \QQ_r^\subs{\Krr^\subs}^{-1}\tilde\ff_r^\subs
    \end{array}
    \f]
    -# Assemble \f$\hat\ff_c\f$ and \f$\hat\ff_\mu\f$:
    \f[
    \begin{array}{ll}
    &\hat\ff_c = \sum_{s} \hat\ff_c^\subs \\
    &\hat\ff_\mu = \sum_s \hat\ff_\mu^\subs
    \end{array}
    \f]
    -# Solve for \f$\tilde\uu_c,~\tilde\mmu\f$:
    \f[
    \begin{bmatrix}
    \tilde \uu_c \\ \tilde\mmu
    \end{bmatrix}
    ={\Kccstar}^{-1}\begin{bmatrix}
    \tilde\ff_c - \hat\ff_c\\ -\hat\ff_\mu
    \end{bmatrix},
    \f]
    -# Back-substitute in parallel to obtain \f$\tilde\uu_r^\subs\f$:
    \f[
    \tilde\uu_r^\subs = {\Krr^\subs}^{-1}(\tilde\ff_r^\subs-\Krc^\subs \tilde\uu_c-{\QQ_r^\subs}^T\tilde\mmu)
    \f]

Steps 2 and 3 are the only steps that involve global operations.
The section below describing the multi-level FETI-DP addresses the bottleneck issue
that arises on an exascale system where the number of equations in \f$\Kccstar\f$ is extremely large,
due to the very high number of subdomains and therefore  processors.
\subsection ml_feti_dp_intro Multi-level FETI-DP
The multi-level FETI-DP is a generalization of the FETI-DP method that applies FETI-DP itself to the solution of the coarse problem governed by the matrix \f$\Kccstar\f$ .
As was mentioned above, this matrix is sparse with a pattern similar to that of a Finite Element model in which the subdomains play the role of elements.
Fundamentally, there is no reason why not to apply FETI-DP to the solution of the coarse system. except thats as mentioned earlier, \f$\Kccstar\f$ as obtained is not positive definite.  
For  problems in solid and structural mechanics, this means that PCG cannot be applied as an iterative method for computing its second-level Lagrange multipliers. Because PCG is more economical than PGMRES, the multi-level FETI-DP method re-formulates the augmentation process in a way that recovers positiveness for the \f$\Kccstar\f$ matrix.

The fundamental reason \f$\Kccstar\f$ in the augmented FETI-DP is not positive is due to the fact that the variables associated with the augmentation are dual DOFs. 
One way to recover positiveness is to replace them by primal DOFs.
\subsubsection primal_gen_dofs Primal Generalized-DOFs
Each column \f$\qq_i\f$ of the augmentation matrix only touches two subdomains, \f$\Omega^{s_1}\f$ and \f$\Omega^{s_2}\f$, with coefficients of opposite signs. Let \f$\alpha_1 = -\alpha_2 = 1\f$. In each of these two subdomains \f$\Omega^{s_k}\f$, \f$k = 1,~2\f$, .
In each subdomain \f$s_k\f$ with \f$k=1,2\f$, let 
\f[
\aa^{s_k}_{2i+k-1} = \alpha_k {\qq_i^{s_k}}^T
\f]
These equations can be used to define an equivalent generalized displacement \f$\uu_{\pi i}\f$ in both \f$\Omega^{s_1}\f$ and \f$\Omega^{s_2}\f$, that is, under the constraint \f$\qq_i \uu_r = 0\f$,
\f[
\uu_{\pi i} = {{\aa^{s_1}_{2 i}}} \uu_r^{s_1}  = {{\aa}^{s_1}_{2i+1}} \uu_r^{s_2}
\f]
Collecting all  \f$\aa^s_j\f$ into a single matrix \f$\AA^s\f$ allows to split the displacement \f$\uu_r^s\f$ as follows:
\f[
\uu_r^s = \hat\uu_r^s + {\AA^s}^T\DD\uu_\pi ~~~~\text{with}~{\AA^s}\hat\uu_r^s = 0
\f]
where \f$\uu_\pi\f$ is a global vector of the primal generalized-DOFs \f$\uu_{\pi i}\f$ and \f$\DD\f$ is a duplication matrix such that \f$\DD_{ji}= \delta_{j,2i-1} + \delta_{j,2i}\f$, allowing \f$\uu_{\pi i}\f$ to affect both subdomains \f$\Omega^{s_1}\f$ and \f$\Omega^{s_2}\f$ .

With \f$\AA\f$ being the row formed by joining all of the \f$\AA^s\f$, the governing equations of the FETI-DP method with primal augmentation can be written as:
\f[
\begin{bmatrix}
\KK_{rr} & \KK_{rc} & \KK_{r\pi} & \AA^T & \BB^T \\
\KK_{cr} & \KK_{cc} & \KK_{c\pi} & \ZO &\ZO  \\
\KK_{\pi r} & \KK_{\pi c} & \KK_{\pi\pi} & \ZO &\ZO  \\
\AA & \ZO & \ZO & \ZO &\ZO \\
\BB & \ZO & \ZO & \ZO & \ZO 
\end{bmatrix}
\begin{bmatrix}
\hat\uu_r \\ \uu_c \\ \uu_\pi \\ \xxi \\ \llambda 
\end{bmatrix} = \begin{bmatrix}
\ff_r \\ \ff_c \\ \ff_\pi \\ \ZO \\ \ZO
\end{bmatrix},
\f]
with
\f[
\begin{array}{rl}
&\KK_{\pi\pi} = \DD^T\AA \KK_{rr} \AA^T\DD \\
& \KK_{\pi r} = \KK_{r\pi}^T= \DD^T\AA \KK_{rr} \\
& \KK_{\pi c} = \KK_{c\pi}^T = \DD^T\AA \KK_{rc} \\
& \ff_\pi = \DD^T\AA\ff_c
\end{array}
\f]
The form of this equation is similar to that pf the classical FETI-DP equation. The main difference can be summarized in two notes:
     - Each Lagrange multipliers associated with  the augmentation process  \f$\xxi_i\f$ is local to a single subdomain.
     - The global problem in \f$\uu_c, \uu_\pi\f$ is symmetric positive definite (SPD).

 Taking advantage of these remarks, reordering the equations and letting \f$\uu_p^T = (\uu_c^T,\uu_\pi^T)\f$,  the FETI-DP system with augmentation becomes:
 \f[
 \begin{bmatrix}
\KK_{rr} & \AA^T & \KK_{rp} &  \BB^T \\
\AA & \ZO & \ZO & \ZO \\
\KK_{ pr} & \ZO & \KK_{pp}  &\ZO  \\
\BB & \ZO & \ZO & \ZO 
\end{bmatrix}
\begin{bmatrix}
\hat\uu_r \\ \xxi \\ \uu_p \\ \llambda 
\end{bmatrix} = \begin{bmatrix}
\ff_r \\  \ZO \\ \ff_c \\ \ZO
\end{bmatrix},
\f]
where the matrices with a \f$p\f$ subscript are blocks formed out of their corresponding terms with \f$c\f$ and \f$\pi\f$ subscripts in the previous governing FETI-DP equation.

Exploiting the remark on the locality of \f$\xxi\f$ the new coarse matrix is obtained by assembling the result of parallel subdomain-per-subdomain operations:
\f[
\KK_{pp}^\star = \sum_{s}  \KK_{pp}^s -
 \begin{bmatrix} \KK_{pr}^s &  \ZO\end{bmatrix}
\begin{bmatrix}
\KK_{rr}^s & {\AA^s}^T \\
\AA^s & \ZO
\end{bmatrix}^{-1}
 \begin{bmatrix} \KK_{rp}^s  \\ \ZO\end{bmatrix}
\f]
For notation simplification, let
\f[
{\KK_{rr}^s}^+ = 
 \begin{bmatrix} \II_r^s &  \ZO\end{bmatrix}
\begin{bmatrix}
\KK_{rr}^s & {\AA^s}^T \\
\AA^s & \ZO
\end{bmatrix}^{-1}
 \begin{bmatrix} \II_r^s  \\ \ZO\end{bmatrix} 
\f]
where \f$\II_r^s\f$ are identity matrices of the size of the remaining DOFs of each subdomain.
Similarly, let \f$\KK_{rr}^+\f$ be the block diagonal matrix formed by the related subdomains matrices.
The FETI-DP governing equation can now be obtained by forming the Schur complement with respect to all variables except \f$\llambda\f$.
After a bit of algebra, the right hand side of this equation becomes:
\f[
\bb = \BB \KK_{rr}^+ \left(\ff_r - \KK_{rp}{\KK_{pp}^\star}^{-1}(\ff_p - \KK_{pr}\KK_{rr}^+ \ff_r)\right)
\f]
and the final governing equation becomes
\f[
\BB \left(\KK_{rr}^+ + \KK_{rr}^+ \KK_{rp}{\KK_{pp}^\star}^{-1}\KK_{pr}\KK_{rr}^+\right)\BB^T \llambda = \FF\llambda = \bb
\f]
Because \f$\KK^*_{pp}\f$ is positive semi-definite, FETI-DP can be applied to the solution of the coarse system, bringing the possibility of the recursive Multi-Level FETI-DP algorithm described below.

\subsection feti_unified_notations Notation Unification
For Helmholtz type problems each level of the multi-level FETI-DP method is used with PGMRES as the iterative solver and does not require the introduction of primal generalized DOFs. Similarly the 
coarse problem of the last level of the multi-level FETI-DP method  for structural problems is solved using a direct method and therefore does not require either the use of primal generalized DOFs.
Hence, the following notation is used in the remainder of this document to simplify the description of the multi-level FETI-DP algorithm:
\f[
{\tilde\KK_{rr}^{s+}} = \left\{ 
\begin{array}{ll}
 \begin{bmatrix} \II_r^s &  \ZO\end{bmatrix}
\begin{bmatrix}
\KK_{rr}^s & {\AA^s}^T \\
\AA^s & \ZO
\end{bmatrix}^{-1}
 \begin{bmatrix} \II_r^s  \\ \ZO\end{bmatrix} &\text{if using primal augmentation}\\
 &\\
\KK_{rr}^{-1} &\text{otherwise}
\end{array}
\right.
\f]
\f[
\tilde\uu_r =  
\left\{ \begin{array}{ll}
 \hat\uu_r &\text{if using primal augmentation}\\
 &\\
 \uu_r& \text{otherwise}
\end{array}\right. 
\f]
\f[
\tilde\uu_c^T =  
\left\{ \begin{array}{ll}
 (\uu_c , \uu_\pi) &\text{if using primal augmentation}\\
 &\\
 (\uu_c , \mmu) & \text{otherwise}
\end{array}\right. 
\f]
\f[
{\tilde\KK_{rc}^s} = {\tilde\KK_{cr}^{s^T}} = \left\{ 
\begin{array}{ll}
\KK_{rp}^s &\text{if using primal augmentation}\\
 &\\
 \begin{bmatrix} \KK_{rc}^s &  {\QQ_r^s}^T\end{bmatrix} &\text{otherwise}
\end{array}
\right.
\f]
\f[
{\tilde\KK_{cc}^s} = \left\{ 
\begin{array}{ll}
\KK_{pp}^s &\text{if using primal augmentation}\\
 &\\
 \begin{bmatrix} \KK_{cc}^s & \ZO \\ \ZO & \ZO\end{bmatrix} &\text{otherwise}
\end{array}
\right.
\f]
Then
\f[
\tilde\KK_{cc}^{\star s} = {\tilde\KK_{cc}^s} - {\tilde\KK_{cr}^s} {\tilde\KK_{rr}^{s+}}{\tilde\KK_{rc}^s}
\f]
and
\f[
\VV = {\tilde\KK_{rr}^{+}}\tilde\KK_{rc}
\f]

subsection{Multi-level FETI-DP Algorithm}
At  level \f$l\f$, given a decomposition \f$D^l = \{\Omega^s | \cup_s \Omega^s = \Omega;~~  \Omega^i\cap\Omega^j = \emptyset \}\f$, the vectors of primal unknowns \f$\uu^s\f$,
the conjugate forces \f$\ff^s\f$ and the system matrices \f$\KK^s\f$:
     -# Pick corner nodes and form \f$\KK_{rr}^s\f$, \f$\KK_{cc}^s\f$, \f$\KK_{rc}^s\f$, \f$\KK_{ii}^s\f$, \f$\KK_{bb}^s\f$ \f$\KK_{ib}^s\f$ and \f$\BB^s\f$
     -# Form the augmentation matrices \f$\QQ^s\f$ if \f$l=l_{max}\f$ or \f$\AA^s\f$ otherwise. 
     -# Factor the local matrices that need to be inverted. (\f${\tilde\KK_{rr}^{s+}}\f$ and \f$\KK_{ii}^s\f$).
     -# Form the local contribution to global coarse problem \f${\tilde\KK_{cc}^s}\f$
     -# Form the coarse solver for \f$\tilde\uu_c = S_c(\tilde\ff_c)\f$:
        - if \f$l < l_{max}\f$ form the decomposition \f$D^{l+1}\f$ by agglomerating the subdomains into meta-subdomains and form the coarse solver \f$S_c(\cdot)\f$ using ML-FETI(l+1)
        - if \f$l = l_{max}\f$ assemble and factor \f$\tilde\KK_{cc}\f$. The use \f$S_c(\cdot) = \tilde\KK_{cc}^{-1} \cdot\f$
     -# Form the right hand side \f$\bb =  \BB {\tilde\KK_{rr}}^+ \left(\ff_r - \tilde\KK_{rc}S_c(\tilde\ff_c - \KK_{pr}{\tilde\KK_{rr}}^+ \ff_r)\right)\f$
     -# Solve \f$\FF\llambda = \bb\f$ using PCG or PGMRES with \f$\MM^{-1}\f$ as preconditioner. 
        - When applying \f$\FF\f$ to any increment \f$\delta\llambda\f$:
            - Compute in parallel in each subdomain \f$\delta \tilde \ff_c^s  = {\VV^s}^T{\BB^s}^T\delta\llambda\f$.
            - Assemble \f$\delta \tilde \ff_c\f$ and apply the coarse solver: \f$\delta \tilde\uu_c = S(\delta\tilde\ff_c)\f$
            - Compute in parallel in each subdomain \f$\delta\tilde\uu_r^s = \tilde\KK_{rr}^+  ({\BB^s}^T\delta\llambda + \VV^s \delta\tilde\uu_c)\f$
            - Communicate to form the jump \f$\BB\delta\tilde\uu_r = \FF\delta\llambda\f$.
        - When applying \f$\MM^{-1}\f$, to a jump vector \f$\rr\f$:
            - Compute in parallel in each subdomain \f$\pp^s = (\KK^s_{bb} - \KK^s_{bi}{\KK^s_{ii}}^{-1}\KK^s_{ib})\rr^s\f$
            - Communicate to assemble the preconditioned residual: \f$\BB \pp = \MM^{-1}\rr \f$.
        - While performing the iterations, accumulate \f$\tilde\uu_r\f$ and \f$\tilde\uu_c\f$. 
     -# If using primal generalized DOFs augmentation, recover \f$\uu_r = \tilde\uu_r + \AA^T\DD\uu_\pi\f$.

*/